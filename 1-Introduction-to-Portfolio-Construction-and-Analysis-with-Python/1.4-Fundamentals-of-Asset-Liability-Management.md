---
title: Fundamentals of Asset-Liability Management
permalink: /1-Introduction-to-Portfolio-Construction-and-Analysis-with-Python/1.4-Fundamentals-of-Asset-Liability-Management/
description:  A deep dive into advanced portfolio optimization strategies, including risk mitigation, diversification tactics, and the use of Geometric Brownian Motion in financial modeling.
last_modified_at: "01-01-2024"
---

<p align="center">
    <img alt="strategies-beyond-diversification"
    src="./resources/Strategies-Beyond-Diversification.jpg"
    width="%"
    height="%">
</p>

<!-- omit in toc -->
# 3. Strategies Beyond Diversification

Summary

===
<!-- omit in toc -->
<div style="font-size:larger;">

**Table of Contents**:

</div>

This segment employs Python libraries to illustrate fundamental principles of Portfolio Optimization:

```python
import pandas as pd  # Utilized for data manipulation
import numpy as np  # Employed for numerical computations
import matplotlib.pyplot as plt  # Applied for creating visualizations
import scipy.stats  # Engaged for statistical calculations
from pandas_datareader import data  # Used to retrieve financial data
from datetime import datetime  # Essential for managing date and time entities
from scipy.optimize import minimize  # Implemented for conducting optimization tasks
import PortfolioOptimizationKit as pok  # A specialized toolkit dedicated to portfolio optimization
import seaborn as sns
from tabulate import tabulate

# Setting up the visualization style
sns.set(style="darkgrid")
```

## Understanding the Time Value of Money

From the initial week's discussions, it's understood that for any specified time frame $(t, t+k)$, where $k>1$, the **`compound return`** over that period is defined as:

$$
R_{t,t+k} = (1+R_{t,t+1})(1+R_{t+1,t+2})\cdots(1+R_{t+k-1,t+k}) - 1,
$$

This equation represents the compounded growth from one period to the next. When returns are constant over each interval, say at a rate $R$ the formula simplifies to:

$$
R_{t,t+k} = (1+R)^{k} - 1.
$$

This simplification assumes a consistent return rate across each time period, compounding the growth.

Assuming $P_t$ as the price at time $t$ and $P_{t+k}$ as the price after all returns have compounded over time, the relationship between the initial and final prices can be expressed as:

$$
P_{t+k} = P_t(1 + R_{t, t+k}) =
\begin{cases}
& P_t \; (1+R_{t,t+1})(1+R_{t+1,t+2})\cdots(1+R_{t+k-1,t+k})\;  & \text{if returns are different}, \\
& P_t \; (1+R)^{k} \;  & \text{if all returns are equal to $R$}.
\end{cases}
$$

The first case handles scenarios where returns vary over different periods, while the second simplifies the calculation when returns are consistent. This illustrates the fundamental principle of the time value of money, where the value of a sum changes over time due to potential returns from investments.

### Exploring Present and Future Value Concepts

In financial terms, $P_{t+k}$ represents the **`future value`**, $FV$, of a sum equivalent to $P_t$.

Conversely, $P_t$ is termed the **`present value`**, $PV$, of the future sum $P_{t+k}$ expected at time $t+k$.

To illustrate, consider an investment of $\$100$ today at a $5\%$ annual interest rate. After one year, this investment would amount to $\$105$. In this context, both $\$100$ today, $PV$, and the future $\$105$, $FV$, one year hence are equivalent for someone anticipating a $5\%$ annual return, assuming no inflation. This exemplifies the concept that $\$100$ today, compounded for one year at $5\%$, yields a future value of $\$105$.

In scenarios where returns $R$ remain constant over time, the relationship between present and future values can be described as follows:

- To determine the **`future value`**, $FV$, from the **`present value`**, $PV$, the formula is:

$$
FV = PV(1 + R)^k.
$$

This equation compounds the present value over $k$ periods at an interest rate of $R$.

- Conversely, to calculate the **`present value`**, $PV$, from a known **`future value`**, $FV$, the formula becomes:

$$
PV = \frac{FV}{(1 + R)^k}.
$$

This formula 'discounts' the future value back to the present, considering the interest rate over $k$ periods.

These equations are fundamental in finance, used for calculating the equivalent value of money at different points in time, accounting for the potential returns (interests) that could be earned if invested.

### Understanding the Discount Rate

The term

$$
\frac{1}{(1+R)^k},
$$

is known as the **`discount factor`**. It represents the present value of $\$1$ unit of currency to be received in $k$ periods, at an interest rate of $R$.

**Scenario Analysis**: Consider being presented with two options: receiving $\$1000$ today or the same amount in three years.

The logical choice is to take the money now. Here's why: if the **`present value`**, $PV$, is $\$1000$, this sum could be invested to accrue additional value over three years. Assuming an annual investment rate of $3\%$, the future value of $\$1000$ today would be:

$$
FV = 1000 (1 + 0.03)^3 = 1.092.7\$.
$$

Opting to receive $\$1000$ in three years means that sum is the future value. To understand its present value, assuming the same interest rate, the calculation is:

$$
PV = \frac{1000}{(1+0.03)^3} = 915,14\$,
$$

This indicates that accepting $\$1000$ in three years is equivalent to receiving $\$915.14$ today, a lesser amount than $\$1000$.

**Another Scenario**: What if the choice is between $\$1000$ today or $\$1100$ in three years?

This decision is more complex. If the hypothetical investment still yields a $3\%$ annual return, then the present value of $\$1150$ after three years is:

$$
PV = \frac{1150}{(1+0.03)^3} = 1052.41\$.
$$

In this case, receiving $\$1150$ in three years is equivalent to $\$1052.41$ today, more than the $\$1000$ immediate option. Therefore, opting to wait for the larger sum is more beneficial.

These examples highlight the importance of understanding the time value of money and how the discount rate can influence financial decisions. The discount factor helps compare the value of money at different times, providing a basis for informed financial choices.

### Grasping the Cumulative Present Value of Future Cash Flows

The cumulative  **`present value`**, $PV$, of future cash flows is a method used to calculate the present worth of a series of future financial inflows and outflows. This technique is pivotal in determining the current value of future sums of money or streams of cash flows given a specified rate of return.

Consider a scenario where Company A has an obligation to pay Company B a sum of $\$25000$ over three years, divided as follows: $\$8000$ in the first year, $\$11000$ in the second year, and $\$6000$ in the third year. Company B applies an annual interest rate of $5\%$. The question arises: what is the present value of this obligation?

The present value of $\$8000$ due in one year (denoted as $FV_1$) is calculated as:

$$
PV_1 = \frac{8000}{1+0.05} = 7619.05\$.
$$

Similarly, for $\$11000$ due in two years ($FV_2$):

$$
PV_2 = \frac{11000}{1+0.05} = 9977.33\$.
$$

and for $\$6000$ due in three years ($FV_3$):

$$
PV_3 = \frac{6000}{1+0.05} = 5183.03\$.
$$

Summing these values gives the present value of the total obligation:

$$
PV_{total} = PV_1 + PV_2 + PV_3 = 22779.4\$.
$$

In a general sense, if future cash flows are denoted as $FV_t$ the present value of a liability $L$ can be represented as:

$$
PV(L) = \sum_{i=1}^N \frac{FV_{t_i}}{(1+R)^{t_i}} := \sum_{i=1}^N B(t_i) L_{t_i},
$$

where $L_{t_i}$ denotes the future cash flow at time $t_i$, and $B(t_i) := 1 / (1+R)^{t_i}$ represents the **`discount factor`**.

```python
# This Python code snippet demonstrates how to calculate the present value of 1 dollar due in 10 years, with an annual interest rate of 3%:
PV = pok.discount(10, 0.03)  # pok.discount is a function from a financial toolkit that calculates the present value.
print(PV)  # Displays the present value in a formatted table.

# To validate the calculation, the future value of this amount is computed:
FV = PV * (1 + 0.03) ** 10  # Computes the future value by compounding the present value at an annual rate of 3% for 10 years.
print(FV)  # Displays the future value in a formatted table.
```

Consider two sets of liabilities (future cash flows) over the next three years:

```python
L = pd.DataFrame([[8000, 11000], [11000, 2000], [6000, 15000]], index=[1, 2, 3])  # Creates a DataFrame representing two series of future cash flows.
print(L)  # Displays the liabilities in a formatted table.
```

Assuming the first liability has an annual rate of $5\%$ and the second one $3\%$, the present value of these liabilities is:

```python
r = [0.05, 0.03]  # Defines interest rates for the two liabilities.
PV = pok.present_value(L, r)  # Calculates the present value of the liabilities using the defined interest rates.
print(PV)  # Displays the present values in a formatted table.
```

The total future values of the liabilities are $\$25000$ and $\$28000$, with their present values approximated to $\$22779.4$ and $\$26292$, respectively. If current assets are equivalent to or exceed these present values, meeting the future obligations wouldn't pose a problem, given the known interest rates. However, if the assets are worth less than these amounts, fulfilling the obligations could become challenging.


### Understanding the Funding Ratio

The funding ratio is a straightforward yet crucial metric used in financial management to ascertain whether the current value of assets is sufficient to cover future liabilities. It is defined as the ratio between the current asset value and the **`present value`**, $PV$, of liabilities:

$$
FR = \frac{\text{assets values}}{{PV(L)}}.
$$

A funding ratio greater than 1 indicates that the current assets are more than adequate to cover the liabilities, whereas a ratio less than 1 signals potential future shortfalls.

Consider a scenario where the present value of a liability, ${PV(L)}$, has been computed, and one needs to evaluate if the current assets are sufficient to meet this obligation.

```python
# Assume current asset values
asset = [20000, 27332] 

# Calculate the funding ratio using the pok.funding_ratio function from the toolkit
FR = pok.funding_ratio(asset, L, r)

# Print the calculated funding ratio in a formatted table
print(tabulate(FR, headers='keys', tablefmt='github'))
```

In this example, if the current assets amount to $\$20000$, they would not be sufficient to cover a future liability of $\$25000$ due in three years for the first liability. Conversely, a current asset value of $\$27332$ would adequately cover a second liability of $\$28000$ due in the same period.

The following function **`show_funding_ratio`** is crafted to visually represent the funding ratio against various rates and asset values:

```python
def show_funding_ratio(asset, L, r):
    fr = pok.funding_ratio(asset, L, r)  # Calculate funding ratio.
    print("Funding ratio: {:.3f}".format(float(fr)))  # Print funding ratio.

    # Set up a two-panel plot for visual representation.
    fig, ax = plt.subplots(1, 2, figsize=(15, 3))

    # Ensure r and fr are of the same length for plotting.
    r_array = np.full_like(fr, r)  # Create an array of r repeated to match fr length.
    
    # Plot the funding ratio against interest rates.
    ax[0].scatter(r_array, fr)
    ax[0].set_xlabel("rates")
    ax[0].set_ylabel("funding ratio")
    ax[0].set_xlim([0.0, max(r_array)*1.1])  # Adjust the x-axis limit based on r values.
    ax[0].set_ylim([min(fr)*0.9, max(fr)*1.1])  # Adjust the y-axis limit based on fr values.
    ax[0].plot(r_array, fr, color="b", alpha=0.5)
    # Draw red dashed lines from the point to the axes.
    ax[0].vlines(x=r, ymin=0, ymax=fr, colors='r', linestyles='dashed')
    ax[0].hlines(y=fr, xmin=0, xmax=r, colors='r', linestyles='dashed')
    ax[0].grid()

    # Handle the case where asset is not iterable.
    if not hasattr(asset, '__iter__'):  # If asset is not an iterable
        asset = [asset]  # Convert it into a list

    # Plot the funding ratio against asset values.
    ax[1].scatter(asset, fr)
    ax[1].set_xlabel("assets")
    ax[1].set_ylabel("funding ratio")
    ax[1].set_xlim([min(asset)*0.9, max(asset)*1.1])  # Adjust the x-axis limit based on asset values.
    ax[1].set_ylim([min(fr)*0.9, max(fr)*1.1])  # Adjust the y-axis limit based on fr values.
    ax[1].plot(asset, fr, color="b", alpha=0.5)
    # Draw red dashed lines from the point to the axes.
    for a in asset:
        ax[1].vlines(x=a, ymin=0, ymax=fr, colors='r', linestyles='dashed')
    ax[1].hlines(y=fr, xmin=0, xmax=max(asset), colors='r', linestyles='dashed')
    ax[1].grid()

    plt.show()  # Display the plots.

# Demonstration of the funding ratio function
r = 0.02  # Define an interest rate.
asset = 24000  # Define an asset value.
L = pd.DataFrame([8000, 11000, 6000], index=[1, 2, 3])  # Define liabilities.
show_funding_ratio(asset, L, r)  # Call the function to display the funding ratio.
```

This function takes the given asset value, liability, and interest rate, computes the funding ratio, and then visualizes how this ratio changes relative to variations in the interest rates and asset values. The plots help understand the sensitivity of the funding ratio to these parameters, allowing for better financial planning and risk assessment.

### Nominal Rate and Effective Annual Interest Rate

Before delving into a stochastic equation that models the variations in interest rates, it's beneficial to revisit compound returns, albeit from a slightly different perspective that introduces a new set of terms.

#### Short-rate vs. Long-Rate (Annualized)

Remember, for a constant return $R$, the compound return over a duration from $t$ to $t+k$ is expressed as:

$$
R_{t,t+k} = (1+R)^{k} - 1.
$$

Take, for instance, the act of borrowing an amount $P := 1\$$, for one year at an annual interest rate of $r_{ann} := 10\%$.
Assuming the repayment is in one installment at the year's end, the return after one year is $10\%$ , leading to a repayment of:

$$
1 + 0.1\cdot 1 = 1.1\$.
$$

Now, consider the scenario where $P$ is borrowed at the same interest rate $r := 10\%$, but repayments are semi-annual. This situation results in a semi-annual rate of $r/2 = 5\%$, accumulating to a total compound return of:

$$
\left(1 + \frac{r}{2}\right)^2 -1 = 0.1025\$,
$$

resulting in a total repayment of $1 + 0.1025\cdot 1= 1.1025\$$.

If repayments were instead monthly, the total would be:

$$
\left(1 + \frac{r}{12}\right)^{12}-1 = 0.1047\$,
$$

leading to a total repayment of $1 + 0.1047\cdot 1= 1.1047\$$.

This illustrates that with more frequent compounding, **`the total compound return increases, necessitating a higher repayment amount.`**

Generally, for a **`nominal interest rate`** $r$ (also known as the **`instantaneous interest rate`**) and $N$ being the **`number of periods`** (or payment intervals for investments, loans, etc.), the total return is:

$$
R = \left(1 + \frac{r}{N}\right)^N - 1.
$$

Here, $R$ represents the **`annualized return`** or **`effective annual interest rate`**, derived from **`discrete compounding`**.

Additionally, the following relationship can be derived from the above formula:

$$
r = N((1+R)^{1/N}-1).
$$

Following the theoretical understanding of nominal and effective annual interest rates, the code below demonstrates the practical calculation using Python. It calculates the effective annual interest rate based on a nominal interest rate and a specified number of compounding periods per year.

```python
# Define the nominal interest rate as 10% and the number of compounding periods as monthly (12 times a year)
nominal_rate = 0.1
periods_per_year = 12

# Calculate the rate for each period (month) and store it in a DataFrame for the first 10 periods
rets = pd.DataFrame([nominal_rate / periods_per_year for i in range(10)])
# Display the first three monthly rates to verify the calculations
print(rets.head(3))
```

The next part of the code computes the annualized return using a function the PortfolioOptomizerKit

```python
# Calculate the annualized return
ann_ret = pok.annualize_rets(rets, periods_per_year)[0]
print("Annualized Return: ", ann_ret)

# Calculate the effective annual interest rate using the formula for discrete compounding
R = (1 + nominal_rate / periods_per_year) ** periods_per_year - 1
print("Effective Annual Interest Rate: ", R)
```

#### Continuous Compounding

When the formula for annualized return is examined, it becomes evident that as $N$ , the number of compounding periods, increases indefinitely, the expression converges to:

$$
\lim_{N\to \infty} \left(1 + \frac{r}{N} \right)^{Nt} = e^{rt},
$$

resulting in the approximation for continuously compounded returns:

$$
R = \lim_{N\to \infty} \left(1 + \frac{r}{N} \right)^{Nt}  - 1 \approx e^{rt} - 1.
$$

Continuous compounding is a theoretical model, but it does have practical applications in certain scenarios.

```python
# Generate a range of N values from 1 to 12, totaling 30 points.
N = np.linspace(1,12,30)
# Define a range of nominal rates from 5% to 20%.
nom_rates = np.arange(0.05,0.2,0.01)

# Initialize a plot with specified size.
fig, ax = plt.subplots(1,1,figsize=(10,6))

# Iterate over each nominal rate.
for r in nom_rates:
    # Plot discrete compounding for each rate and N.
    ax.plot(N, (1 + r / N)**N - 1)
    # Plot the line for continuously compounded return for each rate.
    ax.axhline(y=np.exp(r) -  1, color="r", linestyle="-.", linewidth=0.7)
    # Set the y-label as the formula for discrete compounding.
    ax.set_ylabel("Discrete compounding: (1+r/N)^N - 1")
    # Set the x-label as 'payments (N)'.
    ax.set_xlabel("payments (N)")
# Enable grid for better readability.
plt.grid()
plt.show()
```

This script generates a plot illustrating discrete compounding for various nominal interest rates and the number of payments. It also demonstrates the convergence of discrete compounding to continuous compounding as the number of payments increases.

The graph visualizes the relationship between discrete compounding and the number of payments for different nominal rates, with the continuously compounded return represented by red dashed lines. As the frequency of payments increases, the discrete compounding approaches the continuous compounding rate.

The following Python code snippets illustrate how to calculate discrete and continuous compounding rates using **`pok`** module.

```python
# Assuming 'pok' is a module containing the necessary functions

# Set the nominal rate.
r = 0.1

# Calculate discrete compounding rate with 12 periods per year.
R_disc = pok.compounding_rate(r, periods_per_year=12)
print("Discrete Compounding Rate: ", R_disc)

# Calculate continuous compounding rate.
R_cont = pok.compounding_rate(r)
print("Continuous Compounding Rate: ", R_cont)

# Convert back the continuous compounding rate to the nominal rate.
print("Nominal Rate from Continuous Compounding: ", pok.compounding_rate_inv(R_cont))
```

## CIR Model: Simulating Interest Rate Fluctuations

The **`CIR model`**, named after **`Cox, Ingersoll, and Ross`**, is a mechanism to simulate the variations in interest rates and serves as an enhancement of the **`Vasicek`** model. Its primary function is to circumvent the issue of negative interest rates. As a **`one-factor model`**, or **`short-rate model`**, it posits that interest rate movements are influenced solely by a single market risk factor. This model is often employed in the assessment of interest rate derivatives.

The dynamics of interest rates are defined as follows:

$$
dr_t = a(b-r_t)dt + \sigma\sqrt{r_t}dW_t,
$$

where, $W_t$ represents a Brownian motion, encapsulating the random market risk factor. The term $b$ denotes **`the (long-term) mean interest rate`**, and $b-r_t$ reflects the current deviation of the interest rate from this long-term mean. The parameter $a$ signifies the mean-reversion speed, indicating the rate at which the system returns to the mean interest rate.

The fluctuations in interest rates are therefore contingent on the long-term mean rate ($b$) and the speed at which the rates adjust back to this mean ($a$), after deviations caused by random shocks ($\sigma\sqrt{r_t}dW_t$). Notably, the standard deviation factor $\sigma\sqrt{r_t}$ precludes negative interest rates for all positive $a$ and $b$. Additionally, a zero interest rate is also avoided if $2ab\geq \sigma^2$.

Especially when the rate $r_t$ is nearing zero, the standard deviation $\sigma\sqrt{r_t}$ diminishes, lessening the impact of random fluctuations. In such scenarios, the drift factor predominantly influences the rate, nudging it upward towards equilibrium.

### Applying the CIR Model to Price Zero-Coupon Bonds

In the context of the no-arbitrage principle, zero-coupon bonds can be evaluated using the interest rate process delineated by the CIR model. The price $P(t,T)$ of a zero-coupon bond with maturity $T$ is exponentially affine to the interest rate and is expressed as:

$$
P(t,T) = A(t,T)e^{-B(t,T)r_t},
$$

where

$$
\begin{align}
A(t,T) &:= \left( \frac{ 2h e^{(a+h)\tau/2}  }{ 2h+(a+h)(e^{h\tau}-1) }   \right)^{2ab/\sigma^2}, \\
B(t,T) &:= \frac{ 2(e^{h\tau} - 1)  }{ 2h+(a+h)(e^{h\tau}-1) },  \\
h &:= \sqrt{a^2 + 2\sigma^2}, \\
\tau &:= T - \tau.
\end{align}
$$

Future discussions might delve deeper into this topic.

```python
def show_cir(n_years=10, n_scenarios=10, a=0.05, b=0.05, sigma=0.04, periods_per_year=12, r0=None):
    rates, zcb_price = erk.simulate_cir(n_years=n_years, n_scenarios=n_scenarios, a=a, b=b, sigma=sigma, periods_per_year=periods_per_year, r0=r0)
    
    fig, ax = plt.subplots(1,2,figsize=(20,5))
    rates.plot(ax=ax[0], grid=True, title="CIR model: interest rates", color="indianred", legend=False)
    zcb_price.plot(ax=ax[1], grid=True, title="CIR model: ZCB price", color="indianred", legend=False)

cir_controls = widgets.interact(show_cir, 
                                n_years = (1, 10, 1), 
                                n_scenarios = (1, 200, 1), 
                                a = (0.005, 1, 0.005), 
                                b = (0.002, 0.15, 0.001), 
                                sigma = (0.001, 0.15, 0.001), 
                                periods_per_year = [12, 52, 252], 
                                r0 = (0.002, 0.30, 0.01)
                               )
```
It's crucial to acknowledge that interactive elements are best experienced through a Jupyter notebook, as it provides the necessary interface for ipywidgets. Running these widgets in a standard script or terminal won't yield interactive visualizations. Environments like VSCode, which typically incorporate Jupyter notebook support, facilitate the execution and interaction with these widgets within the editor.

## Liability Hedging

Given a model to project interest rate changes and the corresponding fluctuations in **`zero-coupon`** bond prices, one can evaluate the efficacy of using zero-coupon bonds as a hedge against cash. Variations in interest rates significantly impact future liabilities and funding ratios. Thus, it's prudent to understand how a portfolio might respond to these changes.

The core issue is: **`there is a future liability to be met`**, and with fluctuating interest rates, it's crucial to implement **`a hedging strategy to ensure that the asset's increase in value will suffice`**.

Consider:

```python
# Initial asset amount in millions of dollars
asset_0  = 0.75
# Total liability in millions of dollars
tot_liab = 1

# Nominal rate of the liability
mean_rate = 0.03
# Time horizon for the liability in years
n_years   = 10
# Number of different interest rate scenarios to simulate
n_scenarios = 10
# Number of periods per year for compounding
periods_per_year = 12
```

Here, the initial asset is $0.75 million (**`asset_0`**), and the total liability is $1 million (**`tot_liab`**) due in 10 years. The mean nominal rate of this liability is $3\%$.

### Simulating Interest Rates and Zero-Coupon Bond Prices

Interest rates for the next 10 years are simulated starting from the mean rate:

```python
# Simulate interest rates using the CIR model and calculate corresponding ZCB prices
rates, zcb_price = pok.simulate_cir(n_years=n_years, n_scenarios=n_scenarios, 
                                    a=0.05, b=mean_rate, sigma=0.08, periods_per_year=periods_per_year)
print(rates.head())
```

The liabilities over time are approximated using the simulated zero-coupon bond prices, reflecting the impact of interest rate changes:

```python
# Assign the simulated ZCB prices as the liabilities
L = zcb_price
print(L.head())
```

#### Hedging with Zero-Coupon Bonds

The objective is to meet the liability in 10 years by investing the current assets in a zero-coupon bond:

```python
# Calculate the price of a ZCB maturing in 10 years with a rate equal to the mean rate
zcb = pd.DataFrame(data=[tot_liab], index=[n_years])
zcb_price_0 = pok.present_value(zcb, mean_rate)
print(zcb_price_0)
```

This calculation estimates the present value of a zero-coupon bond that will pay off $1 million plus $3\%$ interest in 10 years. The investment strategy involves purchasing such zero-coupon bonds:

```python
# Calculate the number of bonds that can be bought with the initial assets
n_bonds = float(asset_0 / zcb_price_0)
print(n_bonds)
```

With the number of bonds determined, the future value of the assets invested in the zero-coupon bond can be tracked:

```python
# Calculate the future asset value of the zero-coupon bond investment
asset_value_of_zcb = n_bonds * zcb_price
print(asset_value_of_zcb.head())
```

#### Hedging by Holding Cash

Alternatively, consider holding cash instead of investing in zero-coupon bonds:

```python
# Calculate the future asset value when holding cash, accounting for compounding interest
asset_value_in_cash = asset_0 * (1 + rates/periods_per_year).cumprod()
print(asset_value_in_cash.head())
```

#### Comparing the Two Investment Strategies

Visualizing the future value of both investment strategies:

```python
# Plotting the future values of assets when invested in cash and zero-coupon bonds
fig, ax = plt.subplots(1,2,figsize=(20,5))

asset_value_in_cash.plot(ax=ax[0], grid=True, legend=False, color="indianred", title="Future value of asset put in cash")
asset_value_of_zcb.plot(ax=ax[1], grid=True, legend=False, color="indianred", title="Future value of asset put in ZCB")
ax[0].axhline(y=1.0, linestyle=":", color="black")
ax[1].axhline(y=1.0, linestyle=":", color="black")
ax[0].set_ylabel("millions $")
ax[1].set_ylabel("millions $")
if periods_per_year == 12:
    ax[0].set_xlabel("months ({:.0f} years)".format((len(asset_value_in_cash.index)-1)/periods_per_year))
    ax[1].set_xlabel("months ({:.0f} years)".format((len(asset_value_in_cash.index)-1)/periods_per_year))

plt.show()
```

While the cash investment's increase in value appears smoother, there are scenarios where it fails to meet the $1 million liability. Conversely, despite fluctuations, zero-coupon bond investments consistently meet the required amount at maturity.

The **`funding ratios`** for both investments are then examined:

```python
# Calculate the funding ratios for both cash and zero-coupon bond investments
fr_cash = asset_value_in_cash / L
fr_zcb  = asset_value_of_zcb  / L

# Plotting the funding ratios and their percentage changes for both investments
fig, ax = plt.subplots(2,2,figsize=(20,8))

fr_cash.plot(ax=ax[0,0], grid=True, legend=False, color="indianred", 
             title="Funding ratios of investment in cash ({} scenarios)".format(n_scenarios))
fr_zcb.plot(ax=ax[0,1], grid=True, legend=False, color="indianred", 
            title="Funding ratios of investment in ZCB ({} scenarios)".format(n_scenarios))

ax[0,0].axhline(y=1.0, linestyle=":", color="black")
ax[0,1].axhline(y=1.0, linestyle=":", color="black")

fr_cash.pct_change().plot(ax=ax[1,0], grid=True, legend=False, color="indianred",
                          title="Pct changes in funding ratios of investment in cash ({} scenarios)".format(n_scenarios))
fr_zcb.pct_change().plot(ax=ax[1,1], grid=True, legend=False, color="indianred", 
                         title="Pct changes in funding ratios of investment in ZCB ({} scenarios)".format(n_scenarios))
plt.show()
```

For a more extensive analysis, the **`terminal`** funding ratios are considered:

```python
# Simulate a larger number of scenarios
n_scenarios = 5000
rates, zcb_price = pok.simulate_cir(n_years=n_years, n_scenarios=n_scenarios, a=0.05, 
                                    b=mean_rate, sigma=0.08, periods_per_year=periods_per_year)
# Assign the simulated ZCB prices as liabilities
L = zcb_price
# Recalculate the ZCB and cash investments
zcb = pd.DataFrame(data=[tot_liab], index=[n_years])
zcb_price_0 = pok.present_value(zcb, mean_rate)
n_bonds = float(asset_0 / zcb_price_0)
asset_value_of_zcb = n_bonds * zcb_price
asset_value_in_cash = asset_0 * (1 + rates/periods_per_year).cumprod()

# Calculate terminal funding ratios
terminal_fr_zcb  = asset_value_of_zcb.iloc[-1]  / L.iloc[-1]
terminal_fr_cash = asset_value_in_cash.iloc[-1] / L.iloc[-1]

# Plotting histograms of terminal funding ratios for cash and zero-coupon bond investments
ax = terminal_fr_cash.plot.hist(label="(Terminal) Funding Ratio of investment in cash", bins=50, figsize=(12,5), color="orange", legend=True)
terminal_fr_zcb.plot.hist(ax=ax, grid=True, label="(Terminal) Funding Ratio of investment in ZCB", bins=50, legend=True, color="blue", secondary_y=True)
ax.axvline(x=1.0, linestyle=":", color="k")
ax.set_xlabel("funding ratios")
plt.show()
```

This analysis shows that while cash investments can perform well in many scenarios, there's a significant risk of failing to meet liabilities. Conversely, zero-coupon bond investments consistently provide a funding ratio of at least 1, ensuring the liabilities are met.

## Coupon-Bearing Bonds

Contrasting with zero-coupon bonds, which offer a single cash flow comprising the **`principal`** (also known as the **`face value`**, or **`par value`**) plus accrued interest, a **`coupon-bearing bond`** disburses regular coupons throughout its maturity. The final cash flow includes the last coupon in addition to the principal:

$$
\text{Bond price}= PV = \sum_{i=1}^N \left(\frac{C_{t_i}}{(1+\text{YTM})^{t_i}}\right)  +  \frac{F}{(1+\text{YTM})^{t_N}} 
= C\left(\frac{1-(1+\text{YTM})^{-t_N}}{\text{YTM}}\right) +  \frac{F}{(1+\text{YTM})^{t_N}},
$$

where $N$ is the total number of coupons, $C_{t_i}$ represents the coupon paid at time $t_i$ (all are identical), $F$ is the bond's face value,
and $\text{YTM}$ denotes the yield to maturity. Yield to maturity is the annual rate yield achieved when an investor holds the bond until its maturity.

### Cash Flow from a Bond

Consider a bond's cash flow:

```python
# Bond parameters
principal        = 100 
maturity         = 3
ytm              = 0.05
coupon_rate      = 0.03 
coupons_per_year = 2

# Calculating bond cash flows
cf = pok.bond_cash_flows(principal=principal, maturity=maturity, coupon_rate=coupon_rate, coupons_per_year=coupons_per_year)
print(cf)
```

With bi-annual coupons, each payment is $\$0.015$ (half the coupon rate) over 6 periods, with the final payment including both the face value and the last coupon.

### Bond Price Calculation

The bond's price is calculated as:

```python
# Calculating the bond price given its parameters and YTM
bond_price = pok.bond_price(principal=principal, maturity=maturity, coupon_rate=coupon_rate, coupons_per_year=coupons_per_year, ytm=ytm)
print(bond_price)

# Calculating the total sum paid by the bond if held until maturity 
tot_bond_paym = cf.sum()[0]
print(tot_bond_paym)

# Calculating the gain from investing in the bond
gain = -bond_price + tot_bond_paym
print(gain)
```

The Yield to Maturity (YTM) of 0.05 approximately represents the annual rate that, after compounding, yields a total amount equal to tot_bond_paym from an initial investment equal to bond_price:

```python
# Calculating the annual rate corresponding to the YTM
r = (tot_bond_paym / bond_price )**(1/maturity) - 1
print(r)
```

### Yield to Maturity and Bond Price Relationship

The relationship between the bond's selling price and its face value is dependent on the YTM in relation to the coupon rate:

```python
# Calculating bond prices under different scenarios to illustrate the relationship between YTM and bond price
# Bond selling at a discount: bond price is smaller than face value
pok.bond_price(principal=100, maturity=3, coupon_rate=0.03, coupons_per_year=2, ytm=0.05)

# Bond selling at a premium: bond price is larger than face value
pok.bond_price(principal=100, maturity=3, coupon_rate=0.03, coupons_per_year=2, ytm=0.02)

# Bond selling at par: bond price is equal to face value
pok.bond_price(principal=100, maturity=3, coupon_rate=0.03, coupons_per_year=2, ytm=0.03)

# Plotting the relationship between YTM and bond price
coupon_rate = 0.04
principal = 100
ytm = np.linspace(0.01, 0.10, 20)
bond_prices = [erk.bond_price(maturity=3, principal=principal, coupon_rate=coupon_rate, coupons_per_year=2, ytm=r) for r in ytm]

# Visualizing the bond price as a function of YTM
ax = pd.DataFrame(bond_prices, index=ytm).plot(grid=True, title="Relation between bond price and YTM", figsize=(9,4), legend=False)
ax.axvline(x=coupon_rate, linestyle=":", color="black")
ax.axhline(y=principal, linestyle=":", color="black")
ax.set_xlabel("YTM")
ax.set_ylabel("Bond price (Face value)")
plt.show()
```

The bond sells **`at a discount`** when its price is below the face value, typically when the YTM is greater than the coupon rate. It sells **`at a premium`** when the price exceeds the face value, usually when the YTM is lower than the coupon rate. When the bond sells **`at par`**, its price equals the face value, occurring when the YTM matches the coupon rate. Thus, the bond price and YTM share an inverse relationship.

### Variations in Bond Price

The yield to maturity is not a constant but varies over time. It's an interest rate that fluctuates, consequently altering the bond's price.

#### Observing Price Changes with Interest Rate Fluctuations

To understand how a coupon-bearing bond's price shifts with changing interest rates, consider simulating these rates using the CIR model:

```python
# Simulation parameters
n_years          = 10
n_scenarios      = 10
b                = 0.03  # Long-term mean interest rate
periods_per_year = 2

# Simulating interest rates using the CIR model
rates, _ = pok.simulate_cir(n_years=n_years, n_scenarios=n_scenarios, a=0.02, b=b, sigma=0.02, periods_per_year=periods_per_year)
print(rates.tail())

# Bond characteristics
principal        = 100
maturity         = n_years
coupon_rate      = 0.04
coupons_per_year = periods_per_year

# Calculate bond prices based on the simulated interest rates
bond_prices = pok.bond_price(principal=principal, maturity=maturity, coupon_rate=coupon_rate, 
                             coupons_per_year=coupons_per_year, ytm=rates)

# Plotting the changes in interest rates and corresponding bond prices
fig, ax = plt.subplots(1,2,figsize=(20,5))
rates.plot(ax=ax[0], grid=True, legend=False) 
bond_prices.plot(ax=ax[1], grid=True, legend=False)
ax[0].set_xlabel("months")
ax[0].set_ylabel("interest rate (ytms)")
ax[1].set_xlabel("months")
ax[1].set_ylabel("bond price")
plt.show()
```

The left graph illustrates interest rate changes over time, while the right graph shows the corresponding shifts in bond price. Notably, the price of bonds at maturity converges across all scenarios, reflecting the principal plus coupon-interest.

#### Calculating Total Return of a Coupon-Bearing Bond

To comprehend the total returns of these bonds, one might initially consider the price changes. However, this approach omits coupon payments:

```python
# Computing return by percentage changes in bond price
bond_rets = bond_prices.pct_change().dropna()

# Annualizing the returns
pok.annualize_rets(bond_rets, periods_per_year=periods_per_year)
```

This calculation yields a uniform negative return across all bonds, an artifact of disregarding coupon payments and the coupon rate exceeding the mean interest rate $b$.

In contrast, bonds regularly disburse coupons. To accurately calculate total returns, consider these payments:

```python
# Calculating total bond returns by considering coupon payments
bond_rets = pok.bond_returns(principal=principal, bond_prices=bond_prices, coupon_rate=coupon_rate, 
                             coupons_per_year=coupons_per_year, periods_per_year=periods_per_year)
pok.annualize_rets(bond_rets, periods_per_year=periods_per_year)
```

These figures represent the correctly computed total returns of the bonds, aligning closely with the mean rate $b$ (0.03).

In cases where the bond price and interest rate are fixed, the total return is as follows:

```python
# Setting a fixed yield to maturity
ytm = 0.035
# Calculating the bond price with the given YTM
b_price = pok.bond_price(principal=principal, maturity=maturity, coupon_rate=coupon_rate, coupons_per_year=coupons_per_year, ytm=ytm) 

# Calculating total returns for the bond at the given price
b_ret = pok.bond_returns(principal=principal, bond_prices=b_price, coupon_rate=coupon_rate, 
                         coupons_per_year=coupons_per_year, periods_per_year=periods_per_year, maturity=maturity)

# Displaying the bond price and return
print("Bond price:  {:.6f}".format(b_price))
print("Bond return: {:.6f}".format(b_ret))
```

Here, the return approximates the YTM, demonstrating the relationship between a bond's yield to maturity and its total return.

## Macaulay Duration

**`Macaulay Duration`** represents **`the weighted average time to receive the bond's cash flows`**. Consider a bond with a series of fixed cash flows, including coupon payments and the principal's final payment. The total present value of these cash flows is:

$$
PV = \sum _{i=1}^{N} PV_{i}.
$$

The Macaulay duration is then calculated as:

$$
\text{MacD} 
:= \frac{ \sum_{i=1}^N t_i PV_i}{ \sum _{i=1}^{N} PV_{i} }
= \frac{ \sum_{i=1}^N t_i PV_i}{PV} 
= \sum_{i=1}^N w_i t_i
\quad\text{with}\quad
w_i := \frac{PV_i}{PV}, 
$$

where $PV_{i}$ is the present value of the cash flow paid at time $t_{i}$. For a zero-coupon bond, which only pays at maturity, the Macaulay duration equals the bond's maturity.

### Calculating Macaulay Duration for a Bond

```python
# Bond parameters
principal        = 1000
maturity         = 3
ytm              = 0.06
coupon_rate      = 0.06
coupons_per_year = 2

# Calculating bond cash flows
cf = pok.bond_cash_flows(principal=principal, maturity=maturity, coupon_rate=coupon_rate, coupons_per_year=coupons_per_year)
print(cf)

# Calculating Macaulay Duration using the YTM divided by the number of coupons per year
macd = pok.mac_duration(cf, discount_rate=ytm/coupons_per_year) 
macd = macd / coupons_per_year
print(macd)
```

The calculated duration of the bond is approximately 2.79 years versus the actual maturity of 3 years. The duration is adjusted to reflect the number of total periods (from 1 to 6) by dividing by the number of coupons per year.

### Alternative Approach: Normalizing Cash Flow Dates

```python
# Normalizing cash flows dates
cf = pok.bond_cash_flows(principal=principal, maturity=maturity, coupon_rate=coupon_rate, coupons_per_year=coupons_per_year)
cf.index = cf.index / coupons_per_year
print(cf)

# Calculating Macaulay Duration using only the YTM as discount rate
pok.mac_duration(cf, discount_rate=ytm)
```

In this method, only the YTM is used as the discount rate. The interpretation is that, as the bond pays coupons during its life, the effective time to recoup the investment is less than the maturity due to the receipt of money throughout the bond's term.

### Validating Zero-Coupon Bond Duration

```python
# Zero-Coupon Bond: only one cash flow at maturity
maturity = 3
cf = pd.DataFrame(data=[100], index=[maturity])
# Calculating Macaulay Duration for a zero-coupon bond, the rate is irrelevant
macd = pok.mac_duration(cf, discount_rate=0.05) # the rate does not impact the duration
macd
```

This confirms that for a zero-coupon bond, the Macaulay Duration is equal to the maturity, regardless of the interest rate. This demonstrates that duration is a measure of the time-weighted cash flows of a bond and provides an insight into the bond's sensitivity to interest rate changes.